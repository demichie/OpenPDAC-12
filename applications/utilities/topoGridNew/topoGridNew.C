/*---------------------------------------------------------------------------* \
License
    This file is part of OpenPDAC.

    OpenPDAC is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenPDAC is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenPDAC.  If not, see <http://www.gnu.org/licenses/>.

Application
    topoGrid

Description
    Deforms a polyMesh using an ESRI raster ascii file.

\*---------------------------------------------------------------------------*/

#include "argList.H"
#include "fvMesh.H"
#include "vector.H"
#include "pointFields.H"
#include "IStringStream.H"
#include "volPointInterpolation.H"
#include "UniformTable2.H"
#include "RectangularMatrix.H"
#include <fstream>
#include <sstream>
#include "IOstreams.H"
#include <cstring>
#include "Pstream.H"


using namespace Foam;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// Function to compute the normal vector of a triangle formed by points p1, p2, p3
vector computeNormal(const point& p1, const point& p2, const point& p3)
{
    vector v1 = p2 - p1;  // Edge vector 1
    vector v2 = p3 - p1;  // Edge vector 2

    // Compute the cross product of v1 and v2 to get the normal
    vector normal = Foam::vector
    (
        v1.y() * v2.z() - v1.z() * v2.y(),  // x-component
        v1.z() * v2.x() - v1.x() * v2.z(),  // y-component
        v1.x() * v2.y() - v1.y() * v2.x()   // z-component
    );

    // Normalize the normal vector
    scalar magnitude = mag(normal);
    if (magnitude > SMALL)
    {
        normal /= magnitude;
    }

    return normal;
}

// Function to write a single triangle in binary format
void writeBinaryTriangle(std::ofstream& stlFile, const vector& normal, const point& p1, const point& p2, const point& p3)
{
    // Write normal vector (12 bytes: 3 floats)
    stlFile.write(reinterpret_cast<const char*>(&normal.x()), 4);
    stlFile.write(reinterpret_cast<const char*>(&normal.y()), 4);
    stlFile.write(reinterpret_cast<const char*>(&normal.z()), 4);

    // Write vertex 1 (12 bytes: 3 floats)
    stlFile.write(reinterpret_cast<const char*>(&p1.x()), 4);
    stlFile.write(reinterpret_cast<const char*>(&p1.y()), 4);
    stlFile.write(reinterpret_cast<const char*>(&p1.z()), 4);

    // Write vertex 2 (12 bytes: 3 floats)
    stlFile.write(reinterpret_cast<const char*>(&p2.x()), 4);
    stlFile.write(reinterpret_cast<const char*>(&p2.y()), 4);
    stlFile.write(reinterpret_cast<const char*>(&p2.z()), 4);

    // Write vertex 3 (12 bytes: 3 floats)
    stlFile.write(reinterpret_cast<const char*>(&p3.x()), 4);
    stlFile.write(reinterpret_cast<const char*>(&p3.y()), 4);
    stlFile.write(reinterpret_cast<const char*>(&p3.z()), 4);

    // Write attribute byte count (2 bytes, set to 0)
    char attribute[2] = "0";
    stlFile.write(attribute,2);
}


// Function to write STL surface in binary format
void writeBinarySTL(const word& stlFileName, const RectangularMatrix<scalar>& elevation, scalar xOffset, scalar yOffset, scalar cellSize)
{
    std::ofstream stlFile(stlFileName.c_str(), std::ios::binary);
    if (!stlFile)
    {
        FatalErrorInFunction << "Cannot open STL file " << stlFileName << " for writing" << exit(FatalError);
    }

    // Write 80-byte header (just fill with 0 or any message)
    char header[80] = "Generated by OpenFOAM";
    stlFile.write(header, 80);

    // Get dimensions of the elevation grid
    const label numRows = elevation.m();
    const label numCols = elevation.n();
    
    // Calculate number of triangles (two per cell)
    label numTriangles = 2 * (numRows - 1) * (numCols - 1);
    
    // Write the number of triangles (4 bytes)
    stlFile.write(reinterpret_cast<const char*>(&numTriangles), 4);

    // Loop over each cell in the grid and create two triangles per cell
    for (label i = 0; i < numRows - 1; ++i)
    {
        for (label j = 0; j < numCols - 1; ++j)
        {
            // Get corner points of the cell
            point p1(xOffset + j * cellSize, yOffset + i * cellSize, elevation(i, j));           // Top-left corner
            point p2(xOffset + (j + 1) * cellSize, yOffset + i * cellSize, elevation(i, j + 1));  // Top-right corner
            point p3(xOffset + j * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j));  // Bottom-left corner
            point p4(xOffset + (j + 1) * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j + 1));  // Bottom-right corner

            // First triangle (p1, p2, p3)
            vector normal1 = computeNormal(p1, p2, p3);
            // Info << p1 << p2 << p3 << normal1 << endl;
            writeBinaryTriangle(stlFile, normal1, p1, p2, p3);

            // Second triangle (p2, p4, p3)
            vector normal2 = computeNormal(p2, p4, p3);
            writeBinaryTriangle(stlFile, normal2, p2, p4, p3);
        }
    }

    stlFile.close();
    Info << "Binary STL surface written to " << stlFileName << endl;
}

// Function to write STL surface from the elevation grid
void writeSTL(const word& stlFileName, const RectangularMatrix<scalar>& elevation, scalar xOffset, scalar yOffset, scalar cellSize)
{
    std::ofstream stlFile(stlFileName.c_str());
    if (!stlFile)
    {
        FatalErrorInFunction << "Cannot open STL file " << stlFileName << " for writing" << exit(FatalError);
    }

    // Write STL file header
    stlFile << "solid topoSurface" << endl;

    // Get dimensions of the elevation grid
    const label numRows = elevation.m();
    const label numCols = elevation.n();

    // Loop over each cell in the grid and create two triangles per cell
    for (label i = 0; i < numRows - 1; ++i)
    {
        for (label j = 0; j < numCols - 1; ++j)
        {
            // Get corner points of the cell (elevation grid)
            vector p1(xOffset + j * cellSize, yOffset + i * cellSize, elevation(i, j));           // Top-left corner
            vector p2(xOffset + (j + 1) * cellSize, yOffset + i * cellSize, elevation(i, j + 1));  // Top-right corner
            vector p3(xOffset + j * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j));  // Bottom-left corner
            vector p4(xOffset + (j + 1) * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j + 1));  // Bottom-right corner

            // First triangle (p1, p2, p3) - Top-left, top-right, bottom-left
            vector normal1 = computeNormal(p1, p2, p3);
            stlFile << "  facet normal " << normal1.x() << " " << normal1.y() << " " << normal1.z() << endl;
            stlFile << "    outer loop" << endl;
            stlFile << "      vertex " << p1.x() << " " << p1.y() << " " << p1.z() << endl;
            stlFile << "      vertex " << p2.x() << " " << p2.y() << " " << p2.z() << endl;
            stlFile << "      vertex " << p3.x() << " " << p3.y() << " " << p3.z() << endl;
            stlFile << "    endloop" << endl;
            stlFile << "  endfacet" << endl;

            // Second triangle (p2, p4, p3) - Top-right, bottom-right, bottom-left
            vector normal2 = computeNormal(p2, p4, p3);
            stlFile << "  facet normal " << normal2.x() << " " << normal2.y() << " " << normal2.z() << endl;
            stlFile << "    outer loop" << endl;
            stlFile << "      vertex " << p2.x() << " " << p2.y() << " " << p2.z() << endl;
            stlFile << "      vertex " << p4.x() << " " << p4.y() << " " << p4.z() << endl;
            stlFile << "      vertex " << p3.x() << " " << p3.y() << " " << p3.z() << endl;
            stlFile << "    endloop" << endl;
            stlFile << "  endfacet" << endl;
        }
    }

    // Write STL file footer
    stlFile << "endsolid topoSurface" << endl;

    stlFile.close();
    Info << "STL surface written to " << stlFileName << endl;
}



//---------------------------------------------------------------
scalar inverseDistanceInterpolationDz(const point& internalPoint, const scalarField& boundaryPointsX, const scalarField& boundaryPointsY, const scalarField& boundaryPointsZ, const scalarField& boundaryDz, const scalarField& boundaryAreas, const scalarField& maskPoints)
{

    scalar interpolatedDz(0.0);

    scalar Ldef = 2000.0;
    scalar a = 3;
    scalar b = 5;

    scalar gamma = 5.0;

    // Initialize weights and distance array
    scalarField distances(boundaryDz.size());
    scalarField weights(boundaryDz.size());

    scalarField a_n(maskPoints*boundaryAreas / sum(maskPoints*boundaryAreas));

    if ( internalPoint.z() > 0.0 )
    {
        distances = sqrt( sqr(internalPoint.x()-boundaryPointsX) + sqr(internalPoint.y()-boundaryPointsY)  + sqr(internalPoint.z()-boundaryPointsZ));
    }
    else
    {
        distances = sqrt( sqr(internalPoint.x()-boundaryPointsX) + sqr(internalPoint.y()-boundaryPointsY) );
    }

    scalar minValue = min(distances);
    scalar dzMean = sum(a_n*boundaryDz);
    scalar alpha = gamma / Ldef * max( mag( boundaryDz - dzMean ) );

    if ( minValue < 1.e-7 ) 
    {
        label minIndex = findIndex(distances, minValue);   
        interpolatedDz = boundaryDz[minIndex];    
    }
    else
    {
        weights = boundaryAreas * ( pow((Ldef / distances), a) + pow((alpha * Ldef / distances), b) );  
        interpolatedDz = sum(maskPoints*weights*boundaryDz)/sum(maskPoints*weights);   
    }

    return interpolatedDz;
}


// Function for inverse distance interpolation
vector inverseDistanceInterpolation(const point& internalPoint, const List<point>& boundaryPoints, const List<vector>& boundaryNormals)
{
    scalar Ldef = 1.5;
    scalar alpha = 0.25;
    scalar a = 3;
    scalar b = 5;

    // Initialize weights and distance array
    List<scalar> distances(boundaryPoints.size());
    List<scalar> weights(boundaryPoints.size());

    // Compute the distance between the internal point and each boundary point
    forAll(boundaryPoints, i)
    {
        distances[i] = mag(internalPoint - boundaryPoints[i]);
    }

    // Compute the weights based on inverse distance
    forAll(weights, i)
    {
      //weights[i] = pow(Ldef / distances[i], a) + pow(alpha * Ldef / distances[i], b);
      //      weights[i] = pow(static_cast<double>(Ldef / distances[i]), static_cast<double>(a)) 
        //           + pow(static_cast<double>(alpha * Ldef / distances[i]), static_cast<double>(b));
        //      weights[i] = pow(static_cast<double>(Ldef / distances[i]), static_cast<double>(a))
        // + pow(static_cast<double>(alpha * Ldef / distances[i]), static_cast<double>(b));

        //      weights[i] = pow(static_cast<double>(Ldef / static_cast<double>(distances[i])), static_cast<double>(a))
        //           + pow(static_cast<double>(alpha * Ldef / static_cast<double>(distances[i])), static_cast<double>(b));

      weights[i] = std::pow(static_cast<double>(Ldef / distances[i]), static_cast<double>(a))
           + std::pow(static_cast<double>(alpha * Ldef / distances[i]), static_cast<double>(b));

      
    }

    // Normalize weights
    scalar sumWeights = 0;
    forAll(weights, i)
    {
        sumWeights += weights[i];
    }

    if (sumWeights > SMALL)
    {
        forAll(weights, i)
        {
            weights[i] /= sumWeights;
        }
    }

    // Interpolate normal vector using the weights
    vector interpolatedNormal(0, 0, 0);
    forAll(boundaryNormals, i)
    {
        interpolatedNormal += weights[i] * boundaryNormals[i];
    }


    return interpolatedNormal;
}

template<typename T>
T clamp(const T& value, const T& low, const T& high)
{
    return std::max(low, std::min(value, high));
}



// Correction for normal vectors based on boundary distance
void applyNormalCorrection(const fvMesh& mesh, Field<vector>& pointNormals)
{
    scalar d1 = 0.5;
    scalar d2 = 1.5;

    // Access boundary points and normals
    List<point> boundaryPoints;
    List<vector> boundaryNormals;

    // Extract boundary points and their normal vectors
    forAll(mesh.boundaryMesh(), patchi)
    {

      const fvPatch& patch = mesh.boundary()[patchi];
      //      const fvPatch& patch = mesh.boundaryMesh()[patchi];
        forAll(patch, facei)
        {

          const face& f = mesh.faces()[patch.faceCells()[facei]];
          //          const face& f = patch.face(facei);
          //          const face& f = patch[facei];

          vector normal = mesh.Sf()[patch.faceCells()[facei]] / mag(mesh.Sf()[patch.faceCells()[facei]]);
          //          vector normal = f.area() / mag(f.area());
            forAll(f, pointi)
            {
                boundaryPoints.append(mesh.points()[f[pointi]]);
                boundaryNormals.append(normal);
            }
        }
    }

    // Loop through the internal points and apply normal correction
    forAll(pointNormals, pointIndex)
    {
        const point& p = mesh.points()[pointIndex];
        scalar dist_bdry = GREAT;  // Distance from boundary, update with actual distances

        // Find the minimum distance to the boundary
        forAll(boundaryPoints, bpi)
        {
            scalar dist = mag(p - boundaryPoints[bpi]);
            dist_bdry = min(dist_bdry, dist);
        }

        // Apply buffer zone coefficient
        scalar dist_coeff = clamp((dist_bdry - d1) / (d2 - d1), scalar(0.0), scalar(1.0));
        //        scalar dist_coeff = clamp((dist_bdry - d1) / (d2 - d1), 0.0, 1.0);

        // Adjust the normal based on the distance
        vector interpNormal = inverseDistanceInterpolation(p, boundaryPoints, boundaryNormals);
        pointNormals[pointIndex] = dist_coeff * pointNormals[pointIndex] + (1.0 - dist_coeff) * interpNormal;
    }
}


// Function to apply vertical deformation that fades out near the top boundary
//void applyVerticalDeformation(const Foam::fvMesh& mesh, const Foam::Field<Foam::Vector<double>>& pointDisplacement, scalar zmin, scalar zmax, scalar bottomDeformation);
void applyVerticalDeformation(const fvMesh& mesh, Field<vector>& pointDisplacement, scalar zmin, scalar zmax, const scalar bottomDeformation){

  // Loop through the internal points and apply vertical deformation
    forAll(pointDisplacement, pointIndex)
    {
      const point& p = mesh.points()[pointIndex];
      //  point& p = mesh.points()[pointIndex];

        // Compute the relative height (Zrel) of the current point with respect to the top and bottom boundaries
        scalar Zrel = (zmax - p.z()) / (zmax - zmin);

        // Apply linear scaling to the deformation based on relative height (Zrel)
        scalar vertDeform = bottomDeformation * Zrel;

        // Modify the z-coordinate of the point, gradually reducing the deformation as it gets closer to the top boundary
        pointDisplacement[pointIndex].z() += vertDeform;
    }
}

//--------------------------------------------------------------

//void applyVerticalDeformation(const Foam::fvMesh& mesh, const Foam::Field<Foam::Vector<double>>& pointDisplacement, scalar zmin, scalar zmax, const Foam::List<scalar>& bottomDeformation);

// Function prototype




int main(int argc, char *argv[])
{
#include "setRootCase.H"
#include "createTime.H"
#include "createMesh.H"
  
  // Read the dictionary file (topoGridDict) from the "system" folder
  IOdictionary topoDict
    (
     IOobject
     (
      "topoGridDict",
      runTime.system(),
      mesh,
      IOobject::MUST_READ,
      IOobject::NO_WRITE
      )
     );

  // Read the raster file name from the dictionary
  const word rasterFile = topoDict.lookup<word>("rasterFile");

  // Read the vent center coordinates from the dictionary
  const scalar xVent = topoDict.lookupOrDefault<scalar>("xVent",0.0);
  const scalar yVent = topoDict.lookupOrDefault<scalar>("yVent",0.0);
  const scalar expFactor = topoDict.lookupOrDefault<scalar>("expFactor",1.0);
  const scalar dzVert = topoDict.lookupOrDefault<scalar>("dzVert",0.0);
  const scalar exp_shape = topoDict.lookupOrDefault<scalar>("exp_shape",1.0);
  const Switch saveSTL = topoDict.lookupOrDefault<Switch>("saveSTL", false);
  const Switch saveBinary = topoDict.lookupOrDefault<Switch>("saveBinary", false);

  // Output the file name to the terminal for verification
  Info << "Raster file specified: " << rasterFile << endl;

  // Read the ESRI ASCII Raster file
  std::ifstream file(rasterFile);
    
  if (!file.is_open()) 
    {
      FatalErrorInFunction
        << "Unable to open the raster file: " << rasterFile << exit(FatalError);
    }


  int ncols = 0, nrows = 0;
  double xllcorner = 0.0, yllcorner = 0.0, cellsize = 0.0;
  double NODATA_value = -9999.0;
  std::string line;

  // Read the header
  while (std::getline(file, line))
    {
      std::istringstream iss(line);
      std::string key;
      iss >> key;

      if (key == "ncols")
        iss >> ncols;
      else if (key == "nrows")
        iss >> nrows;
      else if (key == "xllcorner" || key == "xllcenter")
        iss >> xllcorner;
      else if (key == "yllcorner" || key == "yllcenter")
        iss >> yllcorner;
      else if (key == "cellsize")
        iss >> cellsize;
      else if (key == "NODATA_value")
        iss >> NODATA_value;
      if (key == "NODATA_value")
        break;
    }

  xllcorner -= xVent;
  yllcorner -= yVent;

  // Create a RectangularMatrix to store the elevation data
  RectangularMatrix<double> elevation(nrows, ncols, 0.0);

  // Read the elevation data and store it in the RectangularMatrix
  for (int i = 0; i < nrows; ++i)
    {
      std::getline(file, line);
      std::istringstream iss(line);

      for (int j = 0; j < ncols; ++j)
        {
          double value;
          iss >> value;

          if (value == NODATA_value)
            value = 0.0;  // Handle NODATA_value appropriately

          elevation(nrows-1-i, j) = value;
        }
    }

  if (saveSTL)
    {
      // Create the output STL file name based on the input raster file
      word stlFileName(rasterFile);
      stlFileName.replace(".asc", ".stl");
      Info << "Saving STL file: " << stlFileName << endl;

      // Write the STL surface to a file
        
      if (saveBinary)
        {        
          writeBinarySTL(stlFileName, elevation, xllcorner, yllcorner, cellsize);
        }
      else
        {
          writeSTL(stlFileName, elevation, xllcorner, yllcorner, cellsize);        
        }
      Info << "Saving completed" << endl;

    }
    

  double maxTopo(max(elevation));
  // double minTopo(max(elevation));

  scalar zVert(maxTopo + dzVert);

  file.close();

  // Get times list
  instantList Times = runTime.times();

  // skip "constant" time
  for (label timeI = 1; timeI < Times.size(); ++timeI)
    {
      runTime.setTime(Times[timeI], timeI);

      Info<< "Time = " << runTime.userTimeName() << endl;

      scalar zMin = min(mesh.Cf().component(2)).value();
      scalar zMax = max(mesh.Cf().component(2)).value();

      reduce(zMin, minOp<scalar>());
      reduce(zMax, maxOp<scalar>());
    
      Info << "zMin = " << zMin << endl;
      Info << "zMax = " << zMax << endl;
    
      scalar z2Rel(0.0);
      scalar zNew(0.0);


//---------------------------------------------------------------------------------------------

    const vectorField& faceAreas = mesh.faceAreas();
    const vectorField& faceCentres = mesh.faceCentres();
    const scalarField magFaceAreas(mag(faceAreas));
    const vectorField faceNormals = mesh.faceAreas()/mag(faceAreas);

    word patchName = "bottom";  // Hardcode the patchName for boundary of interest

    // Find the ID# associated with the patchName by iterating through boundaryMesh
    label patchID = -1;
    forAll(mesh.boundaryMesh(), patchi)
      {
        if (mesh.boundaryMesh()[patchi].name() == patchName)
          {
            patchID = patchi;
            break;
          }
      }

    if (patchID == -1)
      {
        FatalErrorInFunction << "Patch " << patchName << " not found in mesh." << exit(FatalError);
      }


    // Access the patch
    const fvPatch& patchBottom = mesh.boundary()[patchID];

    scalarField bottomCentresX(patchBottom.size());
    scalarField bottomCentresY(patchBottom.size());
    scalarField bottomCentresZ(patchBottom.size());
    scalarField bottomAreas(patchBottom.size());
    scalarField dzBottom(patchBottom.size());
    // Loop through each face on the patch
    forAll(patchBottom, facei)
    {
        point pCentre = faceCentres[patchBottom.start() + facei];

        // Get x, y coordinates of the pointi
        scalar x = pCentre.x(); 
        scalar y = pCentre.y();
        
        // Calculate row and column indices in the elevation matrix
        int colIndex = (x - xllcorner) / cellsize;
        int rowIndex = (y - yllcorner) / cellsize;

        // Interpolate elevation value
        if (colIndex >= 0 && colIndex <= ncols  && rowIndex >= 0 && rowIndex <= nrows )
        {
            // Bilinear interpolation
            scalar xLerp = (x - (xllcorner + colIndex * cellsize)) / cellsize;
            scalar yLerp = (y - (yllcorner + rowIndex * cellsize)) / cellsize;

            scalar v00 = elevation(rowIndex, colIndex);
            scalar v01 = elevation(rowIndex, colIndex + 1);
            scalar v10 = elevation(rowIndex + 1, colIndex);
            scalar v11 = elevation(rowIndex + 1, colIndex + 1);

            scalar zInterp = 
                v00 * (1 - xLerp) * (1 - yLerp) +
                v01 * xLerp * (1 - yLerp) +
                v10 * (1 - xLerp) * yLerp +
                v11 * xLerp * yLerp;

            bottomCentresX[facei] = faceCentres[patchBottom.start() + facei].x();
            bottomCentresY[facei] = faceCentres[patchBottom.start() + facei].y();
            bottomCentresZ[facei] = faceCentres[patchBottom.start() + facei].z();
            bottomAreas[facei] =  magFaceAreas[patchBottom.start() + facei];
            dzBottom[facei] = zInterp;
        }
        else
        {
            FatalErrorInFunction << "Check asc size" << exit(FatalError);
        }

    }


    patchName = "top";  // Hardcode the patchName for boundary of interest

    // Find the ID# associated with the patchName by iterating through boundaryMesh
    patchID = -1;
    forAll(mesh.boundaryMesh(), patchi)
      {
        if (mesh.boundaryMesh()[patchi].name() == patchName)
          {
            patchID = patchi;
            break;
          }
      }

    if (patchID == -1)
      {
        FatalErrorInFunction << "Patch " << patchName << " not found in mesh." << exit(FatalError);
      }


    // Access the patch
    const fvPatch& patchTop = mesh.boundary()[patchID];
    Info << "" << endl ;
    Info << "patchName = " << patchName << endl ;
    Info << "patchID = " << patchID << endl ;
    Info << "" << endl ;


    scalarField topCentresX(patchTop.size());
    scalarField topCentresY(patchTop.size());
    scalarField topCentresZ(patchTop.size());
    scalarField topAreas(patchTop.size());
    scalarField dzTop(patchTop.size());

    forAll(patchTop, facei)
    {
        point pCentre = faceCentres[patchTop.start() + facei];

        // Get x, y coordinates of the pointi
        scalar x = pCentre.x(); 
        scalar y = pCentre.y();
        
        
        // Calculate row and column indices in the elevation matrix
        int colIndex = (x - xllcorner) / cellsize;
        int rowIndex = (y - yllcorner) / cellsize;

        // Interpolate elevation value
        if (colIndex >= 0 && colIndex <= ncols  && rowIndex >= 0 && rowIndex <= nrows )
        {
            topCentresX[facei] = faceCentres[patchTop.start() + facei].x();
            topCentresY[facei] = faceCentres[patchTop.start() + facei].y();
            topCentresZ[facei] = faceCentres[patchTop.start() + facei].z();
            topAreas[facei] =  magFaceAreas[patchTop.start() + facei];
            dzTop[facei] = 0.0;
        }

    }
    dzTop = 0.0;


    List<scalarField> concatenatedCentresX(Pstream::nProcs());
    concatenatedCentresX[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedCentresY(Pstream::nProcs());
    concatenatedCentresY[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedCentresZ(Pstream::nProcs());
    concatenatedCentresZ[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedDz(Pstream::nProcs());
    concatenatedDz[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedAreas(Pstream::nProcs());
    concatenatedAreas[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> maskFieldAll(Pstream::nProcs());
    maskFieldAll[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> maskFieldBottom(Pstream::nProcs());
    maskFieldBottom[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> maskFieldTop(Pstream::nProcs());
    maskFieldTop[Pstream::myProcNo()].setSize(dzBottom.size() + dzTop.size(), Pstream::myProcNo());

    maskFieldAll[Pstream::myProcNo()] = 1.0;
    
    // Copy the first field into the new field
    for (label i = 0; i < bottomCentresX.size(); ++i)
    {
        concatenatedCentresX[Pstream::myProcNo()][i] = bottomCentresX[i];
        concatenatedCentresY[Pstream::myProcNo()][i] = bottomCentresY[i];
        concatenatedCentresZ[Pstream::myProcNo()][i] = bottomCentresZ[i];
        concatenatedAreas[Pstream::myProcNo()][i] = bottomAreas[i];
        concatenatedDz[Pstream::myProcNo()][i] = dzBottom[i];
        maskFieldBottom[Pstream::myProcNo()][i] = 1.0;
        maskFieldTop[Pstream::myProcNo()][i] = 0.0;
    }

    // Copy the second field into the new field, starting after the end of the first
    for (label i = 0; i < topCentresX.size(); ++i)
    {
        concatenatedCentresX[Pstream::myProcNo()][i + bottomCentresX.size()] = topCentresX[i];
        concatenatedCentresY[Pstream::myProcNo()][i + bottomCentresY.size()] = topCentresY[i];
        concatenatedCentresZ[Pstream::myProcNo()][i + bottomCentresZ.size()] = topCentresZ[i];
        concatenatedAreas[Pstream::myProcNo()][i + bottomAreas.size()] = topAreas[i];
        concatenatedDz[Pstream::myProcNo()][i + dzBottom.size()] = dzTop[i];
        maskFieldBottom[Pstream::myProcNo()][i + bottomCentresX.size()] = 0.0;
        maskFieldTop[Pstream::myProcNo()][i + bottomCentresX.size()] = 1.0;
    }

    Pstream::gatherList<scalarField>(concatenatedCentresX);
    Pstream::scatterList<scalarField>(concatenatedCentresX);

    Pstream::gatherList<scalarField>(concatenatedCentresY);
    Pstream::scatterList<scalarField>(concatenatedCentresY);

    Pstream::gatherList<scalarField>(concatenatedCentresZ);
    Pstream::scatterList<scalarField>(concatenatedCentresZ);

    Pstream::gatherList<scalarField>(concatenatedAreas);
    Pstream::scatterList<scalarField>(concatenatedAreas);

    Pstream::gatherList<scalarField>(concatenatedDz);
    Pstream::scatterList<scalarField>(concatenatedDz);

    Pstream::gatherList<scalarField>(maskFieldAll);
    Pstream::scatterList<scalarField>(maskFieldAll);

    Pstream::gatherList<scalarField>(maskFieldTop);
    Pstream::scatterList<scalarField>(maskFieldTop);

    Pstream::gatherList<scalarField>(maskFieldBottom);
    Pstream::scatterList<scalarField>(maskFieldBottom);

    scalarField globalCentresX;
    scalarField globalCentresY;
    scalarField globalCentresZ;
    scalarField globalDz;
    scalarField globalAreas;
    scalarField globalMaskAll;
    scalarField globalMaskTop;
    scalarField globalMaskBottom;
    
    for (label i = 0; i < Pstream::nProcs(); ++i)
    {
        globalCentresX.append(concatenatedCentresX[i]);
        globalCentresY.append(concatenatedCentresY[i]);
        globalCentresZ.append(concatenatedCentresZ[i]);
        globalDz.append(concatenatedDz[i]);
        globalAreas.append(concatenatedAreas[i]);
        globalMaskAll.append(maskFieldAll[i]);
        globalMaskTop.append(maskFieldTop[i]);
        globalMaskBottom.append(maskFieldBottom[i]);
    }

    Info << "SIZE " << globalMaskAll.size() << endl;

    // std::cout << "Press Enter to continue..." << std::endl;
    // std::cin.get();


    pointField zeroPoints(mesh.points());

    pointField pDeform(0.0*zeroPoints);
    point pEval(zeroPoints[0]);

    scalar interpDz(0.0);

    // Loop over all cells in the mesh to interpolate elevation values
    forAll(pDeform,pointi)
    {

        pEval = mesh.points()[pointi];

        if ( Pstream::myProcNo() == 2)
        {
            Sout << "Proc" << Pstream::myProcNo() << " " << pDeform.size()-pointi << " " << pointi << endl;         
        }
        
        
        if ( pEval.z() > 0.0 )
        {
            if ( mag(pEval.z()-zMax) < 1.e-4 )
            {
                interpDz = 0.0;  
            } 
            else
            {
                interpDz = inverseDistanceInterpolationDz(pEval, globalCentresX, globalCentresY, globalCentresZ, globalDz, globalAreas, globalMaskAll);        
            }
            
        }
        else
        {    
            interpDz = inverseDistanceInterpolationDz(pEval, globalCentresX, globalCentresY, globalCentresZ, globalDz, globalAreas, globalMaskBottom);
        }

        pDeform[pointi].x() = 0.0;  // If outside the raster bounds, set to a default value (e.g., 0)
        pDeform[pointi].y() = 0.0;
        pDeform[pointi].z() = interpDz;
    } // closes pDeform Loop
      
    Sout << "End loop" << endl; 
    pointField newPoints(zeroPoints + pDeform);

    mesh.setPoints(newPoints);

    /*
    const vectorField newFaceNormals = mesh.faceAreas()/mag(faceAreas);
    forAll(patchBottom, facei)
    {
        vector normVect = newFaceNormals[patchBottom.start() + facei];
        Info << "normVect " << normVect << endl;
    }
    */


    mesh.write();


    /*

    vector avgNormal(0, 0, 0); // To store the average normal vector
    Info << "Initial avgNormal = ("  << avgNormal.x() << ", " << avgNormal.y() << ", " << avgNormal.z() << ")" << endl;
    Info << "" << endl ;
    
    // Initialize an array to store normals for each point
    Field<vector> pointNormals(mesh.nPoints(), vector::zero);

    // Initialize an array to count the number of faces contributing to each point's normal
    Field<label> pointFaceCount(mesh.nPoints(), 0);

    // Loop through each face on the patch
    forAll(patch, facei)
      {
        Info << "" << endl;
        Info << "--------------------------------" << endl; 
        Info << "Processing face: " << facei << endl;

            
        const face& f = mesh.faces()[patch.start() + facei];  // Access the face directly from the patch
        const labelList& facePointsIndices = f;  // Get the point indices for the current face

        // Ensure the face has exactly 4 points (for quad faces)
        if (facePointsIndices.size() != 4)
          {
            FatalErrorInFunction << "Expected a face with 4 points, but got " << facePointsIndices.size() << exit(FatalError);
          }

        // Loop through the 4 points of the face to calculate the normal
        for (int pointi = 0; pointi < facePointsIndices.size(); ++pointi)
          {
            label pointIndex = facePointsIndices[pointi];  // Get the index of the point
            point pointP = mesh.points()[pointIndex];  // Access the actual point using the point index

            // Find two other points on the face connected to point P (adjacent points on the face)
            label p1 = facePointsIndices[(pointi + 1) % 4];  // Next point
            label p2 = facePointsIndices[(pointi + 3) % 4];  // Previous point

            point point1 = mesh.points()[p1];
            point point2 = mesh.points()[p2];

            // Compute vectors connecting point P with point1 and point2
            vector v1 = point1 - pointP;
            vector v2 = point2 - pointP;

            // Compute the cross product of v1 and v2 to get the normal
            vector normal = v1 ^ v2;

            // Accumulate the normal for this point
            pointNormals[pointIndex] += normal;
            pointFaceCount[pointIndex]++;  // Increase the face count for averaging

            Info << "Point " << pointIndex << ": accumulated normal = " << pointNormals[pointIndex]
                 << ", face count = " << pointFaceCount[pointIndex] << endl;
          }
      }

    Info << "" << endl; 
    
    // After the loop, compute the average normal for each point by dividing by the face count
    forAll(patch.faceCells(), pointIndex) //pointNormals
      {
        if (pointFaceCount[pointIndex] > 0)
          {
            pointNormals[pointIndex] /= pointFaceCount[pointIndex];  // Compute the average normal

                // Normalize the vector
            // eg., avgNormal /= mag(avgNormal);
            pointNormals[pointIndex] /= mag(pointNormals[pointIndex]);

          }
        Info << "Final average normal for point " << pointIndex << " = " << pointNormals[pointIndex] << endl;
      }


    


 
//-------------------------------------------------------------------------------------------------------------------
    
      //    Info<< nl << "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
      //        << "  ClockTime = " << runTime.elapsedClockTime() << " s"
      //        << nl << endl;
      //    Info<< "End\n" << endl;
      //    Info << "Completed normal vector calculation for patch: " << patchName << endl;

    */
        
    } // closes skip constant time

  // Field to store the point normals and displacements
    Field<vector> pointNormals(mesh.points().size());
    Field<vector> pointDisplacement(mesh.points().size());

    // Boundary deformation parameters
    //    scalar zmin = 0.0;   // Minimum z (bottom boundary)
    //    scalar zmax = 10.0;  // Maximum z (top boundary)
    //    scalar bottomDeformation = 1.0;  // Deformation applied to the bottom boundary

    // Apply normal correction
    //    applyNormalCorrection(mesh, pointNormals);

    // Apply vertical deformation based on relative height
    //  applyVerticalDeformation(mesh, pointDisplacement, zmin, zmax, bottomDeformation);

    // Write the mesh with deformations
    //    mesh.write();


  
    return 0;
} // closes int main()


// ************************************************************************* //
