/*---------------------------------------------------------------------------* \
License
    This file is part of OpenPDAC.

    OpenPDAC is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenPDAC is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenPDAC.  If not, see <http://www.gnu.org/licenses/>.

Application
    topoGrid

Description
    Deforms a polyMesh using an ESRI raster ascii file.

\*---------------------------------------------------------------------------*/

#include "argList.H"
#include "fvMesh.H"
#include "vector.H"
#include "pointFields.H"
#include "IStringStream.H"
#include "volPointInterpolation.H"
#include "UniformTable2.H"
#include "RectangularMatrix.H"
#include <fstream>
#include <sstream>
#include "IOstreams.H"
#include <cstring>
#include "Pstream.H"
#include "tetPointRef.H"
#include "OFstream.H"
#include "globalIndex.H"

using namespace Foam;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// Function to compute the normal vector of a triangle formed by points p1, p2, p3
vector computeNormal(const point& p1, const point& p2, const point& p3)
{
    vector v1 = p2 - p1;  // Edge vector 1
    vector v2 = p3 - p1;  // Edge vector 2

    // Compute the cross product of v1 and v2 to get the normal
    vector normal = Foam::vector
    (
        v1.y() * v2.z() - v1.z() * v2.y(),  // x-component
        v1.z() * v2.x() - v1.x() * v2.z(),  // y-component
        v1.x() * v2.y() - v1.y() * v2.x()   // z-component
    );

    // Normalize the normal vector
    scalar magnitude = mag(normal);
    if (magnitude > SMALL)
    {
        normal /= magnitude;
    }

    return normal;
}

// Function to write a single triangle in binary format
void writeBinaryTriangle(std::ofstream& stlFile, const vector& normal, const point& p1, const point& p2, const point& p3)
{
    // Write normal vector (12 bytes: 3 floats)
    float nx(normal.x());
    float ny(normal.y());
    float nz(normal.z());
    stlFile.write(reinterpret_cast<const char*>(&nx), 4);
    stlFile.write(reinterpret_cast<const char*>(&ny), 4);
    stlFile.write(reinterpret_cast<const char*>(&nz), 4);

    // Write vertex 1 (12 bytes: 3 floats)
    float P1x(p1.x());
    float P1y(p1.y());
    float P1z(p1.z());
    stlFile.write(reinterpret_cast<const char*>(&P1x), 4);
    stlFile.write(reinterpret_cast<const char*>(&P1y), 4);
    stlFile.write(reinterpret_cast<const char*>(&P1z), 4);

    // Write vertex 2 (12 bytes: 3 floats)
    float P2x(p2.x());
    float P2y(p2.y());
    float P2z(p2.z());
    stlFile.write(reinterpret_cast<const char*>(&P2x), 4);
    stlFile.write(reinterpret_cast<const char*>(&P2y), 4);
    stlFile.write(reinterpret_cast<const char*>(&P2z), 4);

    // Write vertex 3 (12 bytes: 3 floats)
    float P3x(p3.x());
    float P3y(p3.y());
    float P3z(p3.z());
    stlFile.write(reinterpret_cast<const char*>(&P3x), 4);
    stlFile.write(reinterpret_cast<const char*>(&P3y), 4);
    stlFile.write(reinterpret_cast<const char*>(&P3z), 4);

    // Write attribute byte count (2 bytes, set to 0)
    char attribute[2] = "0";
    stlFile.write(attribute,2);
}


// Function to write STL surface in binary format
void writeBinarySTL(const word& stlFileName, const RectangularMatrix<scalar>& elevation, scalar xOffset, scalar yOffset, scalar cellSize)
{
    std::ofstream stlFile(stlFileName.c_str(), std::ios::binary);
    if (!stlFile)
    {
        FatalErrorInFunction << "Cannot open STL file " << stlFileName << " for writing" << exit(FatalError);
    }

    // Write 80-byte header (just fill with 0 or any message)
    char header[80] = "Generated by OpenFOAM";
    stlFile.write(header, sizeof(header));

    // Get dimensions of the elevation grid
    const label numRows = elevation.m();
    const label numCols = elevation.n();
    
    // Write triangle count (4 bytes)
    auto triangleCount = static_cast<uint32_t>(2 * (numRows - 1) * (numCols - 1));
    stlFile.write(reinterpret_cast<const char*>(&triangleCount), sizeof(triangleCount));  
    
    // Loop over each cell in the grid and create two triangles per cell
    for (label i = 0; i < numRows - 1; ++i)
    {
        for (label j = 0; j < numCols - 1; ++j)
        {
            // Get corner points of the cell
            point p1(xOffset + j * cellSize, yOffset + i * cellSize, elevation(i, j));           // Top-left corner
            point p2(xOffset + (j + 1) * cellSize, yOffset + i * cellSize, elevation(i, j + 1));  // Top-right corner
            point p3(xOffset + j * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j));  // Bottom-left corner
            point p4(xOffset + (j + 1) * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j + 1));  // Bottom-right corner

            // First triangle (p1, p2, p3)
            vector normal1 = computeNormal(p1, p2, p3);
            // Info << p1 << p2 << p3 << normal1 << endl;
            writeBinaryTriangle(stlFile, normal1, p1, p2, p3);

            // Second triangle (p2, p4, p3)
            vector normal2 = computeNormal(p2, p4, p3);
            writeBinaryTriangle(stlFile, normal2, p2, p4, p3);
        }
    }

    stlFile.close();
    Info << "Binary STL surface written to " << stlFileName << endl;
}

// Function to write STL surface from the elevation grid
void writeSTL(const word& stlFileName, const RectangularMatrix<scalar>& elevation, scalar xOffset, scalar yOffset, scalar cellSize)
{
    std::ofstream stlFile(stlFileName.c_str());
    if (!stlFile)
    {
        FatalErrorInFunction << "Cannot open STL file " << stlFileName << " for writing" << exit(FatalError);
    }

    // Write STL file header
    stlFile << "solid topoSurface" << "\n";

    // Get dimensions of the elevation grid
    const label numRows = elevation.m();
    const label numCols = elevation.n();

    // Loop over each cell in the grid and create two triangles per cell
    for (label i = 0; i < numRows - 1; ++i)
    {
        for (label j = 0; j < numCols - 1; ++j)
        {
            // Get corner points of the cell (elevation grid)
            vector p1(xOffset + j * cellSize, yOffset + i * cellSize, elevation(i, j));           // Top-left corner
            vector p2(xOffset + (j + 1) * cellSize, yOffset + i * cellSize, elevation(i, j + 1));  // Top-right corner
            vector p3(xOffset + j * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j));  // Bottom-left corner
            vector p4(xOffset + (j + 1) * cellSize, yOffset + (i + 1) * cellSize, elevation(i + 1, j + 1));  // Bottom-right corner

            // First triangle (p1, p2, p3) - Top-left, top-right, bottom-left
            vector normal1 = computeNormal(p1, p2, p3);
            stlFile << "  facet normal " << normal1.x() << " " << normal1.y() << " " << normal1.z() << "\n";
            stlFile << "    outer loop" << "\n";
            stlFile << "      vertex " << p1.x() << " " << p1.y() << " " << p1.z() << "\n";
            stlFile << "      vertex " << p2.x() << " " << p2.y() << " " << p2.z() << "\n";
            stlFile << "      vertex " << p3.x() << " " << p3.y() << " " << p3.z() << "\n";
            stlFile << "    endloop" << "\n";
            stlFile << "  endfacet" << "\n";

            // Second triangle (p2, p4, p3) - Top-right, bottom-right, bottom-left
            vector normal2 = computeNormal(p2, p4, p3);
            stlFile << "  facet normal " << normal2.x() << " " << normal2.y() << " " << normal2.z() << "\n";
            stlFile << "    outer loop" << "\n";
            stlFile << "      vertex " << p2.x() << " " << p2.y() << " " << p2.z() << "\n";
            stlFile << "      vertex " << p4.x() << " " << p4.y() << " " << p4.z() << "\n";
            stlFile << "      vertex " << p3.x() << " " << p3.y() << " " << p3.z() << "\n";
            stlFile << "    endloop" << "\n";
            stlFile << "  endfacet" << "\n";
        }
    }

    // Write STL file footer
    stlFile << "endsolid topoSurface" << "\n";

    stlFile.close();
    Info << "STL surface written to " << stlFileName << endl;
}



scalar minQuality
(
    const polyMesh& mesh,
    const point& cC,
    const label fI,
    const bool isOwner,
    const label faceBasePtI
)
{
    // Does fan decomposition of face (starting at faceBasePti) and determines
    // min quality over all resulting tets.

    const pointField& pPts = mesh.points();
    const face& f = mesh.faces()[fI];
    const point& tetBasePt = pPts[f[faceBasePtI]];

    scalar thisBaseMinTetQuality = vGreat;

    for (label tetPtI = 1; tetPtI < f.size() - 1; tetPtI++)
    {
        label facePtI = (tetPtI + faceBasePtI) % f.size();
        label otherFacePtI = f.fcIndex(facePtI);

        label ptAI = -1;
        label ptBI = -1;

        if (isOwner)
        {
            ptAI = f[facePtI];
            ptBI = f[otherFacePtI];
        }
        else
        {
            ptAI = f[otherFacePtI];
            ptBI = f[facePtI];
        }

        const point& pA = pPts[ptAI];
        const point& pB = pPts[ptBI];

        tetPointRef tet(cC, tetBasePt, pA, pB);

        scalar tetQuality = tet.quality();

        if (tetQuality < thisBaseMinTetQuality)
        {
            thisBaseMinTetQuality = tetQuality;
        }
    }
    return thisBaseMinTetQuality;
}



//---------------------------------------------------------------

scalar inverseDistanceInterpolationDz(
    const scalar& Ldef, 
    const scalar& alpha, 
    const point& internalPoint, 
    const scalarField& boundaryPointsX, 
    const scalarField& boundaryPointsY, 
    const scalarField& boundaryPointsZ, 
    const scalarField& boundaryDz, 
    const scalarField& boundaryAreas)
{
    // Initialize variables
    scalar interpolatedDz(0.0);
    const label n = boundaryDz.size();

    // Precompute alpha^5
    const scalar alpha5 = alpha * alpha * alpha * alpha * alpha;

    // Variables for interpolation
    scalar minValue = GREAT;
    label minIndex = -1;

    // Compute distances and find the minimum value in one loop
    scalarField distances(n);
    for (label i = 0; i < n; ++i)
    {
        distances[i] = Foam::sqrt(
            sqr(internalPoint.x() - boundaryPointsX[i]) +
            sqr(internalPoint.y() - boundaryPointsY[i]) +
            sqr(internalPoint.z() - boundaryPointsZ[i])
        );

        if (distances[i] < minValue)
        {
            minValue = distances[i];
            minIndex = i;
        }
    }

    // Special case: very close to a boundary point
    if (minValue < 1.e-5)
    {
        interpolatedDz = boundaryDz[minIndex];
    }
    else
    {
        // General case: inverse distance weighting
        scalar Num(0.0);
        scalar Den(0.0);

        for (label i = 0; i < n; ++i)
        {
            scalar LbyD = Ldef / distances[i];
            scalar LbyD3 = LbyD * LbyD * LbyD;
            scalar weight = boundaryAreas[i] * (LbyD3 + alpha5 * LbyD3 * LbyD * LbyD);
            
            Num += weight * boundaryDz[i];
            Den += weight;
        }

        interpolatedDz = Num / Den;
    }

    return interpolatedDz;
}


Tuple2<scalar, scalar> inverseDistanceInterpolationDzBottom(
    const point& internalPoint,
    const scalarField& boundaryPointsX,
    const scalarField& boundaryPointsY,
    const scalarField& boundaryArea,
    const scalarField& boundaryDz,
    const scalar& interpRelRadius)
{
    scalar interpolatedDz(0.0);
    scalar interpolatedArea(0.0);

    const label n = boundaryDz.size();
    scalar minValue = GREAT;
    label minIndex = -1;

    // Calculate distances and find the minimum in a single loop
    scalarField distances(n);
    for (label i = 0; i < n; ++i)
    {
        distances[i] = Foam::sqrt(
            Foam::sqr(internalPoint.x() - boundaryPointsX[i]) +
            Foam::sqr(internalPoint.y() - boundaryPointsY[i])
        );

        if (distances[i] < minValue)
        {
            minValue = distances[i];
            minIndex = i;
        }
    }

    // Special case: very close to a boundary point
    if (minValue < 1.e-5)
    {
        interpolatedDz = boundaryDz[minIndex];
        interpolatedArea = boundaryArea[minIndex];
    }
    else
    {
        // General case: weighted interpolation
        scalar NumDz(0.0), NumArea(0.0), Den(0.0);

        const scalar radiusThreshold = interpRelRadius * minValue;

        for (label i = 0; i < n; ++i)
        {
            scalar distance = distances[i];
            scalar weight = 1.0 / distance;

            // Neglect points outside the relative radius
            if (distance > radiusThreshold)
                weight = 0.0;

            NumDz += weight * boundaryDz[i];
            NumArea += weight * boundaryArea[i];
            Den += weight;
        }

        interpolatedDz = NumDz / Den;
        interpolatedArea = NumArea / Den;
    }

    return Tuple2<scalar, scalar>(interpolatedDz, interpolatedArea);
}

// Function to calculate the average of a sub-block
double calculateBlockAverage(
    const RectangularMatrix<double>& elevation, 
    label startRow, 
    label startCol, 
    label blockSize, 
    label maxRows, 
    label maxCols) 
{
    double sum = 0.0;
    label count = 0;

    for (label i = startRow; i < startRow + blockSize && i < maxRows; ++i) {
        for (label j = startCol; j < startCol + blockSize && j < maxCols; ++j) {
            sum += elevation(i, j);
            ++count;
        }
    }

    return sum / count;
}

RectangularMatrix<double> subsampleMatrix(const RectangularMatrix<double>& elevation, int ncols, int nrows, label blockSize) {
    // Original dimensions
    

    // New dimensions
    label newRows = nrows / blockSize;
    label newCols = ncols / blockSize;

    // Create a new matrix for the subsampled data
    RectangularMatrix<double> subsampled(newRows, newCols, 0.0);

    // Fill the subsampled matrix
    for (label i = 0; i < newRows; ++i) {
        for (label j = 0; j < newCols; ++j) {
            subsampled(i, j) = calculateBlockAverage(
                elevation, 
                i * blockSize, 
                j * blockSize, 
                blockSize, 
                nrows, 
                ncols);
        }
    }

    return subsampled;
}


template<typename T>
T clamp(const T& value, const T& low, const T& high)
{
    return std::max(low, std::min(value, high));
}


//--------------------------------------------------------------

int main(int argc, char *argv[])
{
#include "setRootCase.H"
#include "createTime.H"
#include "createMesh.H"
  
  // Read the dictionary file (topoGridDict) from the "system" folder
  IOdictionary topoDict
    (
     IOobject
     (
      "topoGridDict",
      runTime.system(),
      mesh,
      IOobject::MUST_READ,
      IOobject::NO_WRITE
      )
     );

  // Read the raster file name from the dictionary
  const word rasterFile = topoDict.lookup<word>("rasterFile");

  // Read the vent center coordinates from the dictionary
  const scalar xVent = topoDict.lookupOrDefault<scalar>("xVent",0.0);
  const scalar yVent = topoDict.lookupOrDefault<scalar>("yVent",0.0);
  const scalar expFactor = topoDict.lookupOrDefault<scalar>("expFactor",1.0);
  const scalar dzVert = topoDict.lookupOrDefault<scalar>("dzVert",0.0);
  const scalar interpRelRadius = topoDict.lookupOrDefault<scalar>("interpRelRadius",4.0);
  const scalar exp_shape = topoDict.lookupOrDefault<scalar>("exp_shape",1.0);
  const Switch saveSTL = topoDict.lookupOrDefault<Switch>("saveSTL", false);
  const Switch saveBinary = topoDict.lookupOrDefault<Switch>("saveBinary", false);
  const Switch checkMeshFlag = topoDict.lookupOrDefault<Switch>("checkMeshFlag", false);

  // Output the file name to the terminal for verification
  Info << "Raster file specified: " << rasterFile << endl;

  // Read the ESRI ASCII Raster file
  std::ifstream file(rasterFile);
    
  if (!file.is_open()) 
    {
      FatalErrorInFunction
        << "Unable to open the raster file: " << rasterFile << exit(FatalError);
    }


  int ncols = 0, nrows = 0;
  double xllcorner = 0.0, yllcorner = 0.0, cellsize = 0.0;
  double NODATA_value = -9999.0;
  std::string line;

  // Read the header
  while (std::getline(file, line))
    {
      std::istringstream iss(line);
      std::string key;
      iss >> key;

      if (key == "ncols")
        iss >> ncols;
      else if (key == "nrows")
        iss >> nrows;
      else if (key == "xllcorner" || key == "xllcenter")
        iss >> xllcorner;
      else if (key == "yllcorner" || key == "yllcenter")
        iss >> yllcorner;
      else if (key == "cellsize")
        iss >> cellsize;
      else if (key == "NODATA_value")
        iss >> NODATA_value;
      if (key == "NODATA_value")
        break;
    }

  xllcorner -= xVent;
  yllcorner -= yVent;

  // Create a RectangularMatrix to store the elevation data
  RectangularMatrix<double> elevation(nrows, ncols, 0.0);

  // Read the elevation data and store it in the RectangularMatrix
  for (int i = 0; i < nrows; ++i)
    {
      std::getline(file, line);
      std::istringstream iss(line);

      for (int j = 0; j < ncols; ++j)
        {
          double value;
          iss >> value;

          if (value == NODATA_value)
            value = 0.0;  // Handle NODATA_value appropriately

          elevation(nrows-1-i, j) = value;
        }
    }

  if (saveSTL)
    {
    
      // Subsample the matrix with a factor of 4
      label factor = 2;
      RectangularMatrix<double> elevationSubsampled = subsampleMatrix(elevation, ncols, nrows, factor);

      scalar xllSubsampled(xllcorner+(0.5*factor)*cellsize);
      scalar yllSubsampled(yllcorner+(0.5*factor)*cellsize);

      scalar cellsizeSubsampled(factor*cellsize);
    
      // Create the output STL file name based on the input raster file
      word stlFileName(rasterFile);
      stlFileName.replace(".asc", ".stl");
      Info << "Saving STL file: " << stlFileName << endl;

      // Write the STL surface to a file
        
      if (saveBinary)
        {        
          writeBinarySTL(stlFileName, elevationSubsampled, xllSubsampled, yllSubsampled, cellsizeSubsampled);
        }
      else
        {
          writeSTL(stlFileName, elevationSubsampled, xllSubsampled, yllSubsampled, cellsizeSubsampled);        
        }
      Info << "Saving completed" << endl;

    }
    
  file.close();

  // Get times list
  instantList Times = runTime.times();

  // skip "constant" time
  for (label timeI = 1; timeI < Times.size(); ++timeI)
    {
      runTime.setTime(Times[timeI], timeI);

      Info<< "Time = " << runTime.userTimeName() << endl;

      scalar xMin = min(mesh.Cf().component(0)).value();
      scalar xMax = max(mesh.Cf().component(0)).value();

      reduce(xMin, minOp<scalar>());
      reduce(xMax, maxOp<scalar>());

      Info << "xMin = " << xMin << endl;
      Info << "xMax = " << xMax << endl;

      scalar yMin = min(mesh.Cf().component(1)).value();
      scalar yMax = max(mesh.Cf().component(1)).value();

      reduce(yMin, minOp<scalar>());
      reduce(yMax, maxOp<scalar>());

      Info << "yMin = " << yMin << endl;
      Info << "yMax = " << yMax << endl;

      scalar zMin = min(mesh.Cf().component(2)).value();
      scalar zMax = max(mesh.Cf().component(2)).value();

      reduce(zMin, minOp<scalar>());
      reduce(zMax, maxOp<scalar>());
    
      Info << "zMin = " << zMin << endl;
      Info << "zMax = " << zMax << endl;
 
      scalar Ldef(0.5*std::sqrt( sqr(xMax-xMin) + sqr(yMax-yMin) + sqr(zMax-zMin) ));

      Info << "Ldef = " << Ldef << endl << endl;

    
      scalar z2Rel(0.0);
      scalar zNew(0.0);


//---------------------------------------------------------------------------------------------

    const vectorField& faceAreas = mesh.faceAreas();
    const vectorField& faceCentres = mesh.faceCentres();
    const scalarField magFaceAreas(mag(faceAreas));
    const vectorField faceNormals = mesh.faceAreas()/mag(faceAreas);
    const faceList& faces = mesh.faces();
    
    // List of indexes of faces with z=0
    labelList faceIndices;

    // Pupolate list of faces at z=0, by iterating over all the mesh faces
    forAll(faces, faceI)
    {
        // Check z of face
        if (mag(faceCentres[faceI].z()) < 1.e-3) // Usa SMALL per tolleranza numerica
        {
            // Add the face index
            faceIndices.append(faceI);
        }
    }

    Sout << "Proc" << Pstream::myProcNo() << " z=0 faces " << faceIndices.size() << endl;

    // Create fieds for face coords, areas and dz
    scalarField bottomCentresX(faceIndices.size());
    scalarField bottomCentresY(faceIndices.size());
    scalarField bottomCentresZ(faceIndices.size());
    scalarField bottomAreas(faceIndices.size());
    scalarField dzBottom(faceIndices.size());

    // Loop through each face in the list and compute dz with bilinear interpolation
    forAll(faceIndices, facei)
    {
        point pCentre = faceCentres[faceIndices[facei]];

        // Get x, y coordinates of the pointi
        scalar x = pCentre.x(); 
        scalar y = pCentre.y();
        
        // Calculate row and column indices in the elevation matrix
        int colIndex = (x - xllcorner) / cellsize;
        int rowIndex = (y - yllcorner) / cellsize;

        // Interpolate elevation value
        if (colIndex >= 0 && colIndex <= ncols  && rowIndex >= 0 && rowIndex <= nrows )
        {
            // Bilinear interpolation
            scalar xLerp = (x - (xllcorner + colIndex * cellsize)) / cellsize;
            scalar yLerp = (y - (yllcorner + rowIndex * cellsize)) / cellsize;

            scalar v00 = elevation(rowIndex, colIndex);
            scalar v01 = elevation(rowIndex, colIndex + 1);
            scalar v10 = elevation(rowIndex + 1, colIndex);
            scalar v11 = elevation(rowIndex + 1, colIndex + 1);

            scalar zInterp = 
                v00 * (1 - xLerp) * (1 - yLerp) +
                v01 * xLerp * (1 - yLerp) +
                v10 * (1 - xLerp) * yLerp +
                v11 * xLerp * yLerp;

            bottomCentresX[facei] = faceCentres[faceIndices[facei]].x();
            bottomCentresY[facei] = faceCentres[faceIndices[facei]].y();
            bottomCentresZ[facei] = faceCentres[faceIndices[facei]].z();
            bottomAreas[facei] =  magFaceAreas[faceIndices[facei]];
            dzBottom[facei] = zInterp-faceCentres[faceIndices[facei]].z();
            

        }
        else
        {
            FatalErrorInFunction << "Check asc size" << exit(FatalError);
        }

    }


    // Create points from coords to save in an external file
    pointField points(bottomCentresX.size());
    forAll(points, i)
    {
        points[i] = vector(bottomCentresX[i], bottomCentresY[i], dzBottom[i]);
    }

    // Scrive i punti in un file di testo
    /*
    OFstream outFile(runTime.path()/"centers.txt");
    forAll(points, i)
    {
        outFile << points[i].x() << ", " << points[i].y() << ", " << points[i].z() << "\n";
    }

    Info << "Centers saved in file centers.txt" << endl;
    */ 
    // Start the merging of points from different processors
    // We need to create global fields containing the points for the
    // deformation of the z=0 faces only
    
    
    // First of all create list with nproc fields
    List<scalarField> CentresX(Pstream::nProcs());
    CentresX[Pstream::myProcNo()].setSize(dzBottom.size(), Pstream::myProcNo());

    List<scalarField> CentresY(Pstream::nProcs());
    CentresY[Pstream::myProcNo()].setSize(dzBottom.size(), Pstream::myProcNo());

    List<scalarField> Dz(Pstream::nProcs());
    Dz[Pstream::myProcNo()].setSize(dzBottom.size(), Pstream::myProcNo());

    List<scalarField> Areas(Pstream::nProcs());
    Areas[Pstream::myProcNo()].setSize(dzBottom.size(), Pstream::myProcNo());

    // Each processor populate its field in the list of fields
    for (label i = 0; i < bottomCentresX.size(); ++i)
    {
        CentresX[Pstream::myProcNo()][i] = bottomCentresX[i];
        CentresY[Pstream::myProcNo()][i] = bottomCentresY[i];
        Areas[Pstream::myProcNo()][i] = bottomAreas[i];
        Dz[Pstream::myProcNo()][i] = dzBottom[i];
    }

    // Use gather and scatter to have the full lists for all the processors
    
    Pstream::gatherList<scalarField>(CentresX);
    Pstream::scatterList<scalarField>(CentresX);

    Pstream::gatherList<scalarField>(CentresY);
    Pstream::scatterList<scalarField>(CentresY);

    Pstream::gatherList<scalarField>(Areas);
    Pstream::scatterList<scalarField>(Areas);

    Pstream::gatherList<scalarField>(Dz);
    Pstream::scatterList<scalarField>(Dz);

    // Create the global fields
    scalarField globalPX;
    scalarField globalPY;
    scalarField globalPDz;
    scalarField globalPAreas;
    
    for (label i = 0; i < Pstream::nProcs(); ++i)
    {
        globalPX.append(CentresX[i]);
        globalPY.append(CentresY[i]);
        globalPDz.append(Dz[i]);
        globalPAreas.append(Areas[i]);
    }

    double maxTopo(max(globalPDz));
    // double minTopo(max(elevation));

    scalar zVert(maxTopo + dzVert);



    Info << "z=0 faces " << globalPAreas.size() << endl;

    pointField zeroPoints(mesh.points());
    pointField pDeform(0.0*zeroPoints);

    const globalIndex globalPoints(mesh.nPoints());

    // Local number of points and cells
    label localNumPoints = mesh.points().size();

    // Output the global number of points and cells
    Info << "Local number of points: " << localNumPoints << endl;
    
    reduce(localNumPoints, sumOp<scalar>());  // global sum   
    
    label globalNumPoints(localNumPoints);
    
    // Output the global number of points and cells
    Info << "Global number of points: " << globalNumPoints << endl << endl;
    

    // Lists for the face vertexes at z=0 and for the area and deformation at these points
    scalarList pX;
    scalarList pY;
    scalarList pZ;
    scalarList pArea;
    scalarList pDz;
    labelList  localIdx;

    point pEval(zeroPoints[0]);
    
    // Loop over the points with z=0 to compute the deformation from the face centers
    forAll(pDeform,pointi)
    {

        pEval = mesh.points()[pointi];

        if ( mag(pEval.z()) < 1e-3 )
        {    

            Tuple2<scalar, scalar> result;

            result = inverseDistanceInterpolationDzBottom(pEval, globalPX, 
                                               globalPY, globalPAreas, globalPDz, interpRelRadius);

            scalar interpDz = result.first();
            scalar interpArea = result.second();   
            
            pX.append( pEval.x() );
            pY.append( pEval.y() );
            pZ.append( 0.0 );
            pArea.append( interpArea );
            pDz.append( interpDz );
            localIdx.append( pointi );

        }

    } 

    // create list of labels in the original global mesh
    labelList globalIdx(localIdx.size());
    forAll(localIdx, pointi)
    {
        globalIdx[pointi] = globalPoints.toGlobal(pointi);
    }

    syncTools::syncPointList
    (
        mesh,
        localIdx,
        globalIdx,
        minEqOp<label>(),
        labelMax
    );


    Sout << "Proc" << Pstream::myProcNo() << " z=0 points " << pArea.size() << endl;

    // Local number of points and cells
    label globalZ0Points = pArea.size();
    
    reduce(globalZ0Points, sumOp<scalar>());  // global sum   

    Info << "Total z=0 points " << globalZ0Points << endl;
      
    word patchName = "top";  // Hardcode the patchName for boundary of interest

    // Find the ID# associated with the patchName by iterating through boundaryMesh
    label patchID = -1;
    forAll(mesh.boundaryMesh(), patchi)
      {
        if (mesh.boundaryMesh()[patchi].name() == patchName)
          {
            patchID = patchi;
            break;
          }
      }

    if (patchID == -1)
      {
        FatalErrorInFunction << "Patch " << patchName << " not found in mesh." << exit(FatalError);
      }


    // Access the patch
    const fvPatch& patchTop = mesh.boundary()[patchID];

    Sout << "Proc" << Pstream::myProcNo() << " zTop faces/points " << patchTop.size() << endl;

    // Local number of points and cells
    label globalZtopPoints = patchTop.size();
    
    reduce(globalZtopPoints, sumOp<scalar>());  // global sum   

    Info << "Total z=zTop points " << globalZtopPoints << endl;

    label nGlobalPoints(globalZ0Points+globalZtopPoints); 

    Info << "Total interpolation points (including duplicated points) " << nGlobalPoints << endl;


    scalarField topCentresX(patchTop.size());
    scalarField topCentresY(patchTop.size());
    scalarField topCentresZ(patchTop.size());
    scalarField topAreas(patchTop.size());
    scalarField dzTop(patchTop.size());
    labelField globalIdxTop(patchTop.size());

    forAll(patchTop, facei)
    {
        topCentresX[facei] = faceCentres[patchTop.start() + facei].x();
        topCentresY[facei] = faceCentres[patchTop.start() + facei].y();
        topCentresZ[facei] = faceCentres[patchTop.start() + facei].z();
        topAreas[facei] =  magFaceAreas[patchTop.start() + facei];
        dzTop[facei] = maxTopo; 
        globalIdxTop[facei] = -1;       
    }

    List<scalarField> concatenatedPointsX(Pstream::nProcs());
    concatenatedPointsX[Pstream::myProcNo()].setSize(pDz.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedPointsY(Pstream::nProcs());
    concatenatedPointsY[Pstream::myProcNo()].setSize(pDz.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedPointsZ(Pstream::nProcs());
    concatenatedPointsZ[Pstream::myProcNo()].setSize(pDz.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedDz(Pstream::nProcs());
    concatenatedDz[Pstream::myProcNo()].setSize(pDz.size() + dzTop.size(), Pstream::myProcNo());

    List<scalarField> concatenatedAreas(Pstream::nProcs());
    concatenatedAreas[Pstream::myProcNo()].setSize(pDz.size() + dzTop.size(), Pstream::myProcNo());

    List<labelField> concatenatedGlobalIndex(Pstream::nProcs());
    concatenatedGlobalIndex[Pstream::myProcNo()].setSize(pDz.size() + dzTop.size(), Pstream::myProcNo());


    // Copy the first field into the new field
    for (label i = 0; i < pDz.size(); ++i)
    {
        concatenatedPointsX[Pstream::myProcNo()][i] = pX[i];
        concatenatedPointsY[Pstream::myProcNo()][i] = pY[i];
        concatenatedPointsZ[Pstream::myProcNo()][i] = pZ[i];
        concatenatedAreas[Pstream::myProcNo()][i] = pArea[i];
        concatenatedDz[Pstream::myProcNo()][i] = pDz[i];
        concatenatedGlobalIndex[Pstream::myProcNo()][i] = globalIdx[i];
    }

    // Copy the second field into the new field, starting after the end of the first
    for (label i = 0; i < topCentresX.size(); ++i)
    {
        concatenatedPointsX[Pstream::myProcNo()][i + pX.size()] = topCentresX[i];
        concatenatedPointsY[Pstream::myProcNo()][i + pY.size()] = topCentresY[i];
        concatenatedPointsZ[Pstream::myProcNo()][i + pZ.size()] = topCentresZ[i];
        concatenatedAreas[Pstream::myProcNo()][i + pArea.size()] = topAreas[i];
        concatenatedDz[Pstream::myProcNo()][i + pDz.size()] = dzTop[i];
        concatenatedGlobalIndex[Pstream::myProcNo()][i + pDz.size()] = globalIdxTop[i];
    }

    Pstream::gatherList<scalarField>(concatenatedPointsX);
    Pstream::gatherList<scalarField>(concatenatedPointsY);
    Pstream::gatherList<scalarField>(concatenatedPointsZ);
    Pstream::gatherList<scalarField>(concatenatedAreas);
    Pstream::gatherList<scalarField>(concatenatedDz);
    Pstream::gatherList<labelField>(concatenatedGlobalIndex);

    Pstream::scatterList<scalarField>(concatenatedPointsX);
    Pstream::scatterList<scalarField>(concatenatedPointsY);
    Pstream::scatterList<scalarField>(concatenatedPointsZ);
    Pstream::scatterList<scalarField>(concatenatedAreas);
    Pstream::scatterList<scalarField>(concatenatedDz);
    Pstream::scatterList<labelField>(concatenatedGlobalIndex);

    scalarField globalPointsX(nGlobalPoints);
    scalarField globalPointsY(nGlobalPoints);
    scalarField globalPointsZ(nGlobalPoints);
    scalarField globalDz(nGlobalPoints);
    scalarField globalAreas(nGlobalPoints);
    
    // bool for points alreay added    
    boolList addedPoint(globalNumPoints, false);
    
    label totPoints(0);
    
    // loop over processors to create global list removing duplicated points
    for (label i = 0; i < Pstream::nProcs(); ++i)
    {
        Info << "Merging proc " << i << endl;
        forAll(concatenatedDz[i],pi)
        {
            // The points belonging to more than one processor
            // should not be added twice
            // "accept" becomes false when the point already exists
            label globalI = concatenatedGlobalIndex[i][pi];            

            bool accept(true);
            
            if ( globalI > 0)
            {
                if ( addedPoint[globalI] )
                {
                    accept = false;
                    // Info << "Point " << globalI << " already added" << endl;
                }
                else
                {
                    addedPoint[globalI] = true;
                }
            }
            
            if (accept)
            {                
                globalPointsX[totPoints] = concatenatedPointsX[i][pi];
                globalPointsY[totPoints] = concatenatedPointsY[i][pi];
                globalPointsZ[totPoints] = concatenatedPointsZ[i][pi];
                globalDz[totPoints] = concatenatedDz[i][pi];
                globalAreas[totPoints] = concatenatedAreas[i][pi];
                totPoints++;
            }            
        }
    }
    
    globalPointsX.setSize(totPoints);
    globalPointsY.setSize(totPoints);
    globalPointsZ.setSize(totPoints);
    globalDz.setSize(totPoints);
    globalAreas.setSize(totPoints);
    
    Info << "Global points for deformation " << totPoints << endl;

    /*
    if ( Pstream::myProcNo() == 0 )
    {

        // Scrive i punti in un file di testo
        OFstream outFileNew(runTime.path()/"pointsNEW.txt");

        forAll(globalPointsX,pi)
        {
            if ( mag(globalPointsZ[pi]-zMax) > 1.e-3 )
            {
                outFileNew << globalPointsX[pi] << ", " << globalPointsY[pi] << ", " << globalDz[pi] << "\n";        
            }
        }    
    }
    */
    
 
    scalar gamma = 5.0;
    scalarField a_n(globalAreas / sum(globalAreas));
    scalar dzMean(sum(a_n*globalDz));
    scalar alphaAll = gamma / Ldef * max( mag( globalDz - dzMean ) );

    Info << "alpha " << alphaAll << endl;

    scalar interpDz(0.0);
    scalar interpDz0(0.0);
    scalar interpDz1(0.0);

    alphaAll = 10.0;

    scalar zExp = 5.0;

    const label totalPoints = mesh.points().size();
    // const label nProcs = Pstream::nProcs();  // Total number of processors
    // const label procRank = Pstream::myProcNo();  // Current processor rank

    label localCount = 0;  // Count of processed points by this processor
    // Loop over all points in the mesh to interpolate vertical deformation
    scalar nextPctg(1.0);
    scalar percentage(0.0);
    
    forAll(pDeform,pointi)
    {     
           
        localCount++;      
        percentage = 100.0 * static_cast<scalar>(localCount) / totalPoints;
        // reduce(percentage, minOp<scalar>());

        if ( percentage >= nextPctg )
        {
            Info << "Progress: " << nextPctg << "% completed." << endl;
            
            if ( nextPctg >= 100.0 )
            {
                Sout << "Proc" << Pstream::myProcNo() << " deformation completed" << endl; 
            }
            
            nextPctg += 1.0;            
        }
          
        pEval = mesh.points()[pointi];

        scalar zRel = max(0.0,min(1.0, (zMax-pEval.z())/(zMax-0.0)));
               
        if ( pEval.z() > 1.e-3 )
        {
            if ( mag(pEval.z()-zMax) < 1.e-3 )
            {
                interpDz = maxTopo;  
            } 
            else
            {
                // interpolation based on full 3D weighted inverse distance 
                interpDz0 = inverseDistanceInterpolationDz(Ldef, alphaAll, pEval, globalPointsX, 
                                    globalPointsY, globalPointsZ, globalDz, globalAreas);        

                // interpolation based on (x,y) coordinates and with linear dependence on zRel
                Tuple2<scalar, scalar> result;

                result = inverseDistanceInterpolationDzBottom(pEval, globalPX, globalPY, 
                                    globalPAreas, globalPDz, interpRelRadius);
                 
                interpDz1 = zRel * result.first() + ( 1.0-zRel ) * maxTopo;

                // mixed interpolation (interpDz1 at bottom and interpDz0 at top)
                interpDz = std::pow(zRel,zExp)*interpDz1 + (1.0-std::pow(zRel,zExp))*interpDz0;
                // interpDz = interpDz1;                
            }
 
            // elevation of the deformed point, used to compute the enlargement
            zNew = pEval.z() + interpDz;
                
            if (dzVert > 0)
            {
                // enlarge from a fixed height above the maximum
                // topography and the top, thus from an horizontal
                // plane to the top
                z2Rel = max(0, (zNew - zVert) / (zMax + maxTopo - zVert));
            }
            else
            {
                // enlarge from the topography to the top
                z2Rel = (zNew - interpDz) / (zMax + maxTopo - interpDz);
            }
            z2Rel = std::pow(z2Rel,exp_shape);
                
            pDeform[pointi].x() = z2Rel*(expFactor-1.0)*pEval.x();
            pDeform[pointi].y() = z2Rel*(expFactor-1.0)*pEval.y();
             
        }
        else
        {    
            // interpolation for z<=0
            
            /*
            interpDz = inverseDistanceInterpolationDz(Ldef, alphaAll, pEval, 
                                   globalPointsX, globalPointsY, globalPointsZ, globalDz, 
                                   globalAreas);
            */

            // interpolation based on (x,y) coordinates and with linear dependence on zRel
            Tuple2<scalar, scalar> result;

            result = inverseDistanceInterpolationDzBottom(pEval, globalPX, globalPY, 
                                globalPAreas, globalPDz, interpRelRadius);
                 
            interpDz = result.first();

            pDeform[pointi].x() = 0.0;
            pDeform[pointi].y() = 0.0;

        }

        pDeform[pointi].z() = interpDz;
    } // closes pDeform Loop
      

    pointField newPoints(zeroPoints + pDeform);
    mesh.setPoints(newPoints);

    Sout << "Proc" << Pstream::myProcNo() << " mesh updated" << endl; 

    if ( checkMeshFlag )
    {
        const faceList& pFaces = mesh.faces();
        const pointField& pPts = mesh.points();

        forAll(faceIndices, facei)
        {

            face f = pFaces[faceIndices[facei]];

            // Compute an estimate of the centre as the average of the points
            point pAvg = Zero;

            forAll(f, fp)
            {
                pAvg += pPts[f[fp]];
            }
            pAvg /= f.size();

            // Compute the face area normal and unit normal by summing up the
            // normals of the triangles formed by connecting each edge to the
            // point average.
            vector sumA = Zero;

            forAll(f, fp)
            {
                const point& p = pPts[f[fp]];
                const point& pNext = pPts[f.nextLabel(fp)];

                const vector a = (pNext - p)^(pAvg - p);

                sumA += a;
            }
            const vector sumAHat = normalised(sumA);

            // Compute the area-weighted sum of the triangle centres. Note use
            // the triangle area projected in the direction of the face normal
            // as the weight, *not* the triangle area magnitude. Only the
            // former makes the calculation independent of the initial estimate.
            scalar sumAn = 0;
            vector sumAnc = Zero;
            forAll(f, fp)
            {
                const point& p = pPts[f[fp]];
                const point& pNext = pPts[f.nextLabel(fp)];

                const vector a = (pNext - p)^(pAvg - p);
                const vector c = p + pNext + pAvg;

                const scalar an = a & sumAHat;

                sumAn += an;
                sumAnc += an*c;
            }

            point fc = (1.0/3.0)*sumAnc/sumAn;

            // Calculate the sum of magnitude of areas and compare to magnitude
            // of sum of areas.

            scalar summA = 0.0;
            vector sumN(0.0,0.0,0.0);

            forAll(f, fp)
            {
                const point& thisPoint = pPts[f[fp]];
                const point& nextPoint = pPts[f.nextLabel(fp)];

                // Triangle around fc.
                const vector n = 0.5*((nextPoint - thisPoint)^(fc - thisPoint));
            
                summA += mag(n);
                sumN += n;
            }

            scalar magArea = mag(sumN);
            scalar faceFlatness = magArea/(summA);  
            if ( faceFlatness < 0.98 )
            {   
                Sout << "Proc" << Pstream::myProcNo() << " face " << facei 
                     << " centre " << fc << " flatness " << faceFlatness << endl; 
            }               
        }
    }
    /*

    const vectorField& fCtrs = mesh.faceCentres();
    const vectorField& pC = mesh.cellCentres();
    const labelList& pOwner = mesh.faceOwner();
    const vectorField& fAreas = mesh.faceAreas();

    scalar minQ(1.0);
    // Loop through each midified reference face 
    forAll(faceIndices, facei)
    {

        face f = pFaces[faceIndices[facei]];

        label oCI = pOwner[faceIndices[facei]];

        point oCc = pC[oCI];

        minQ = 1.0;

        forAll(f, faceBasePtI)
        {
            minQ = minQuality(mesh, oCc, faceIndices[facei], true, faceBasePtI);
        }
        
        if (minQ < 1e-15)
        {
            Sout << "Proc" << Pstream::myProcNo() << " face " << facei << " minQ " << minQ << endl; 
            forAll(f,ip)
            {
                Sout << ip << " coord " << pPts[f[ip]] << endl;
            }
            Sout << " oCc " << oCc << endl;
        }

        const point& fc = fCtrs[faceIndices[facei]];

        // Calculate the sum of magnitude of areas and compare to magnitude
        // of sum of areas.

        scalar sumA = 0.0;
        vector sumN(0.0,0.0,0.0);

        forAll(f, fp)
        {
            const point& thisPoint = pPts[f[fp]];
            const point& nextPoint = pPts[f.nextLabel(fp)];

            // Triangle around fc.
            const vector n = 0.5*((nextPoint - thisPoint)^(fc - thisPoint));
            
            sumA += mag(n);
            sumN += n;
        }

        scalar magArea = mag(sumN);
        scalar faceFlatness = magArea/(sumA + rootVSmall);  
        if ( faceFlatness < 0.98 )
        {     
            Sout << "Proc" << Pstream::myProcNo() << " face " << facei << " flatness " << faceFlatness << endl; 
        }               
    }
    */
    

    Info << "Writing new mesh" << endl;
    mesh.write();

    Info<< nl << "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
        << "  ClockTime = " << runTime.elapsedClockTime() << " s"
        << nl << endl;

    Info<< "End\n" << endl;

    } // closes skip constant time

    return 0;
} // closes int main()


// ************************************************************************* //
